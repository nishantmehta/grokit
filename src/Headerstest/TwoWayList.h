//
//  Copyright 2012 Alin Dobra and Christopher Jermaine
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

#ifndef _TWO_WAY_LIST_H
#define _TWO_WAY_LIST_H

// Includes the basic TwoWayList as well as Keyify and Swapify
// (the other basic templates were removed from this file for clarity; their
// files are included below in order to make everything backwards compatible)

/** Changelog

  June 5, 2009; Alin; Added iterator interface on top of the map. The iterator
  interface of the underlying TwoWayList

  June 10, 2009; Alin; Made the copy constructor and opertor= private. Subtle
  bugs appear if the default constructors generated by the compiler are used.
  It is also against the Swapping paradigm.

  June 18, 2009; Alin; Simplified the Swapify and Keyify
  templates. Now they work only if the argument has the == and =
  operator defined. This is not a limitation since all basic types have that
*/

#include <iostream>
#include "Swap.h"
#include "Config.h"
#include "SerializeJson.h"
#include "Swapify.h"

// Helper macros for Frequently Done Actions
// Macro to streamline scan of TwoWayLists
// list "list" is scanned and element is local variable that is
// instantiated as each element of the list
// Usage Scenario:
//   FOREACH_TWL(val, myList){
//     do something with val
//   }END_FOREACH
//
//
#ifdef _HAS_AUTO
#define FOREACH_TWL(el, list) \
    for((list).MoveToStart(); !(list).AtEnd(); (list).Advance()) { \
        auto & el = (list).Current();
#else // _HAS_AUTO
#define FOREACH_TWL(el, list) \
    for((list).MoveToStart();   !(list).AtEnd(); (list).Advance()) { \
        typeof((list).Current())& el = (list).Current();
#endif // _HAS_AUTO

#ifndef END_FOREACH
#define END_FOREACH }
#endif

// This is a template for a doubly linked list
// Type requires only the function swap ()...
template <class Type>
class TwoWayList {

public:
    // type definitions to make our life easier
    typedef Type element;

    // do a deep copy of the param that is sent in
    void copy (TwoWayList<Type> &me);

    // basic constructor function
    TwoWayList ();

    // deconstructor function
    virtual ~TwoWayList ();

    // swap operator
    void swap (TwoWayList<Type> & List);

    // deep copy (needs CopyFrom on Type)
    void CopyFrom(TwoWayList<Type> & List);

    // remove all the content
    void Clear(void);

    // add to current pointer position
    void Insert (Type & Item);

    // add at the end of the list
    void Append (Type & Item);

    // look at the current item
    Type &Current () const;

    // remove from current position
    void Remove (Type & Item);

    // move the current pointer position backward through the list
    void Retreat () const;

    // move the current pointer position forward through the list
    void Advance () const;

    // operations to check the size of both sides
    int LeftLength () const;
    int RightLength () const;
    int Length() const;

    // check if empty
    bool IsEmpty() const;

    // operations to consult state
    bool AtStart () const;
    bool AtEnd () const;

    // operations to swap the left and right sides of two lists
    void SwapLefts (TwoWayList<Type> & List);
    void SwapRights (TwoWayList<Type> & List);

    // operations to move the the start of end of a list
    void MoveToStart () const;
    void MoveToFinish () const;

    // removes the contents of one list from another
    void Subtract (TwoWayList<Type> & takeMeOut);

    // fuction to merge two lists (steals the content from the argument
    void SuckUp(TwoWayList<Type> & suckMe);

    /* We cannot have these functions called ToJson and FromJson since
    the compiler gets confused when the template is instantiated and
    cannot find the correct global function to call for the inner
    class */

    // Go To/From JSON
    void toJson( Json::Value & dest ) const;
    void fromJson( const Json::Value & src );

private:

    struct Node {
        // data
        Type data;
        Node *next;
        Node *previous;

        // constructor
        Node () : next (0), previous (0) {}
        virtual ~Node () {}
    };

    struct Header {
        // data
        Node * first;
        Node * last;
        mutable Node * current;
        mutable int leftSize;
        mutable int rightSize;
    };

    // the list itself is pointed to by this pointer
    Header *list;

    // making the default constructor and = operator private so  the list
    // can only be propagated by swap. Otherwise subtle bugs can appear
    TwoWayList(TwoWayList<Type>&);
    TwoWayList operator = (TwoWayList<Type>&);
};

template< typename T >
void ToJson( const TwoWayList<T> & src, Json::Value & dest ) {
    src.toJson(dest);
}

template< typename T >
void FromJson( const Json::Value & src, TwoWayList<T> & dest ) {
    dest.fromJson(src);
}

template< class Type >
void swap( TwoWayList<Type>& a, TwoWayList<Type>& b ) {
    a.swap(b);
}

#include "TwoWayList.cc"

#endif
